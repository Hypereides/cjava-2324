/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl pre_c_init();
WINBOOL __fastcall CRT_INIT(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
__int64 __fastcall readExpression(__int64 a1);
void *__fastcall decode_pointer(void *codedptr);
void *__fastcall encode_pointer(void *ptr);
void _report_error(const char *msg, ...);
void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len);
void __cdecl pei386_runtime_relocator();
void __cdecl _do_global_dtors();
void __cdecl _do_global_ctors();
void __cdecl _main();
void __cdecl _security_init_cookie();
void __fastcall _report_gsfailure(ULONG_PTR StackCookie);
int __fastcall _mingw_SEH_error_handler(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext);
int __cdecl _mingw_init_ehandler();
int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data);
BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
int __fastcall _tlregdtor(_PVFV func);
_onexit_t __fastcall mingw_onexit(_onexit_t func);
int __fastcall atexit(_PVFV func);
WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase);
WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase);
PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva);
PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName);
PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p);
int __cdecl _mingw_GetSectionCount();
PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo);
PBYTE __cdecl GetPEImageBase();
WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget);
const char *__fastcall _mingw_enum_import_library_names(int i);
void __cdecl fpreset();
void __cdecl _mingwthr_run_key_dtors_part_0();
int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *));
int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key);
WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
BOOL __fastcall DllEntryPoint(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
// void *__cdecl malloc(size_t Size);
// __int64 __fastcall amsg_exit(_QWORD); weak
// void __cdecl free(void *Block);
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// FILE *__cdecl _iob_func();
// int __cdecl fflush(FILE *Stream);
// int printf(const char *const Format, ...);
// int scanf(const char *const Format, ...);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// void __cdecl __noreturn abort();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// __int64 __fastcall lock(_QWORD); weak
// __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unlock(_QWORD); weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl calloc(size_t Count, size_t Size);
// __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

func_ptr *_data_start__ = (func_ptr *)0x674829F8i64; // idb
UINT_PTR _security_cookie = 47936899621426ui64; // idb
UINT_PTR _security_cookie_complement = 18446696136809930189ui64; // idb
const EXCEPTION_POINTERS GS_ExceptionPointers = { &GS_ExceptionRecord, &GS_ContextRecord }; // idb
int *refptr__CRT_MT = &CRT_MT; // weak
__int64 (*refptr___CTOR_LIST__)[2] = &__CTOR_LIST__; // weak
void *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ = &_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak
void *refptr___RUNTIME_PSEUDO_RELOC_LIST__ = &_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak
__int64 (__fastcall **refptr___dyn_tls_init_callback)() = &_dyn_tls_init_callback; // weak
const PBYTE refptr___image_base__ = (const PBYTE)0x67480000i64; // idb
void *refptr___imp__onexit = &_onexit; // weak
__int64 *refptr___native_startup_lock = &_native_startup_lock; // weak
__enative_startup_state *refptr___native_startup_state = &_native_startup_state; // weak
__int64 *refptr___onexitbegin = &_onexitbegin; // weak
__int64 *refptr___onexitend = &_onexitend; // weak
_PVFV *const refptr___xc_a = &_xc_a; // idb
_PVFV *const refptr___xc_z = &_xc_z; // idb
_PVFV *const refptr___xi_a = &_xi_a; // idb
_PVFV *const refptr___xi_z = &_xi_z; // idb
int _bss_start__; // idb
int was_init_73980; // idb
int maxSections; // idb
sSecInfo *the_secs; // idb
int initialized; // idb
CONTEXT GS_ContextRecord; // idb
EXCEPTION_RECORD GS_ExceptionRecord; // idb
LPTOP_LEVEL_EXCEPTION_FILTER _mingw_oldexcpt_handler; // idb
int was_here_73812; // idb
UNWIND_INFO emu_xdata[32]; // idb
RUNTIME_FUNCTION emu_pdata[32]; // idb
volatile __mingwthr_key_t *key_dtor_list; // idb
volatile int _mingwthr_cs_init; // idb
CRITICAL_SECTION _mingwthr_cs; // idb
_PVFV *_onexitbegin; // idb
_PVFV *_onexitend; // idb
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress);
// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern FILE *(__cdecl *__iob_func)();


//----- (0000000067481000) ----------------------------------------------------
int __cdecl pre_c_init()
{
  _QWORD *v0; // rbx
  void *v1; // rax
  int result; // eax

  v0 = malloc(0x100ui64);
  v1 = encode_pointer(v0);
  *refptr___onexitbegin = (__int64)v1;
  *refptr___onexitend = (__int64)v1;
  if ( !v0 )
    return 1;
  result = 0;
  *v0 = 0i64;
  return result;
}
// 67484220: using guessed type __int64 *refptr___onexitbegin;
// 67484230: using guessed type __int64 *refptr___onexitend;

//----- (0000000067481050) ----------------------------------------------------
WINBOOL __fastcall CRT_INIT(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  WINBOOL result; // eax
  signed __int64 v6; // rsi
  signed __int64 v7; // rax
  int v8; // esi
  void (**v9)(void); // rbp
  void (**v10)(void); // rsi
  void (*v11)(void); // rdx

  if ( dwReason )
  {
    result = 1;
    if ( dwReason == 1 )
    {
      v6 = *((_QWORD *)NtCurrentTeb() + 1);
      while ( 1 )
      {
        v7 = _InterlockedCompareExchange64(refptr___native_startup_lock, v6, 0i64);
        if ( !v7 )
        {
          v8 = 0;
          goto LABEL_15;
        }
        if ( v6 == v7 )
          break;
        Sleep(0x3E8u);
      }
      v8 = 1;
LABEL_15:
      if ( *refptr___native_startup_state == __enative_startup_state::__initializing )
      {
        amsg_exit(31i64);
      }
      else if ( *refptr___native_startup_state == __enative_startup_state::__uninitialized )
      {
        *refptr___native_startup_state = __enative_startup_state::__initializing;
        initterm(refptr___xi_a, refptr___xi_z);
      }
      if ( *refptr___native_startup_state == __enative_startup_state::__initializing )
      {
        initterm(refptr___xc_a, refptr___xc_z);
        *refptr___native_startup_state = __enative_startup_state::__initialized;
      }
      if ( !v8 )
        _InterlockedExchange64(refptr___native_startup_lock, 0i64);
      if ( *refptr___dyn_tls_init_callback )
        ((void (__fastcall *)(HANDLE, __int64, LPVOID))*refptr___dyn_tls_init_callback)(hDllHandle, 2i64, lpreserved);
      ++_bss_start__;
      return 1;
    }
  }
  else if ( _bss_start__ <= 0 )
  {
    return 0;
  }
  else
  {
    --_bss_start__;
    while ( _InterlockedCompareExchange64(refptr___native_startup_lock, 1i64, 0i64) )
      Sleep(0x3E8u);
    if ( *refptr___native_startup_state == __enative_startup_state::__initialized )
    {
      v9 = (void (**)(void))decode_pointer((void *)*refptr___onexitbegin);
      if ( v9 )
      {
        v10 = (void (**)(void))decode_pointer((void *)*refptr___onexitend);
        while ( v9 <= --v10 )
        {
          while ( 1 )
          {
            v11 = *v10;
            if ( !*v10 )
              break;
            --v10;
            v11();
            if ( v9 > v10 )
              goto LABEL_31;
          }
        }
LABEL_31:
        free(v9);
        *refptr___onexitend = 0i64;
        *refptr___onexitbegin = 0i64;
      }
      *refptr___native_startup_state = __enative_startup_state::__uninitialized;
      _InterlockedExchange64(refptr___native_startup_lock, 0i64);
      return 1;
    }
    else
    {
      amsg_exit(31i64);
      return 1;
    }
  }
  return result;
}
// 67482898: using guessed type __int64 __fastcall amsg_exit(_QWORD);
// 674841C0: using guessed type __int64 (__fastcall **refptr___dyn_tls_init_callback)();
// 67484200: using guessed type __int64 *refptr___native_startup_lock;
// 67484210: using guessed type __enative_startup_state *refptr___native_startup_state;
// 67484220: using guessed type __int64 *refptr___onexitbegin;
// 67484230: using guessed type __int64 *refptr___onexitend;

//----- (0000000067481430) ----------------------------------------------------
__int64 __fastcall readExpression(__int64 a1)
{
  FILE *v1; // rax
  FILE *v2; // rax
  __int64 v4; // [rsp+30h] [rbp-20h] BYREF
  __int64 v5; // [rsp+38h] [rbp-18h] BYREF
  int v6; // [rsp+40h] [rbp-10h] BYREF

  v1 = __iob_func();
  fflush(v1);
  printf("Enter the expression (e.g. + 1/4 2/4): ");
  scanf("%c %d/%d  %d/%d", &v4, (char *)&v4 + 4, &v5, (char *)&v5 + 4, &v6);
  v2 = __iob_func();
  fflush(v2);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 16) = v6;
  return a1;
}

//----- (00000000674814D0) ----------------------------------------------------
void *__fastcall decode_pointer(void *codedptr)
{
  return codedptr;
}

//----- (00000000674814E0) ----------------------------------------------------
void *__fastcall encode_pointer(void *ptr)
{
  return ptr;
}

//----- (00000000674814F0) ----------------------------------------------------
void __noreturn _report_error(const char *msg, ...)
{
  FILE *v2; // rax
  FILE *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, msg);
  v2 = _iob_func();
  fwrite("Mingw-w64 runtime failure:\n", 1ui64, 0x1Bui64, v2 + 2);
  v3 = _iob_func();
  vfprintf(v3 + 2, msg, va);
  abort();
}

//----- (0000000067481560) ----------------------------------------------------
void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len)
{
  __int64 v3; // rbp
  int v7; // r9d
  PBYTE *p_sec_start; // rax
  PIMAGE_SECTION_HEADER SectionForAddress; // rax
  PIMAGE_SECTION_HEADER v10; // r12
  __int64 v11; // rbp
  sSecInfo *v12; // r13
  DWORD LastError; // eax
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+20h] [rbp-68h] BYREF

  v3 = maxSections;
  if ( maxSections <= 0 )
  {
    v3 = 0i64;
LABEL_6:
    SectionForAddress = _mingw_GetSectionForAddress(addr);
    v10 = SectionForAddress;
    if ( !SectionForAddress )
      _report_error("Address %p has no image-section", addr);
    v11 = v3;
    v12 = &the_secs[v11];
    v12->hash = SectionForAddress;
    v12->old_protect = 0;
    v12->sec_start = &GetPEImageBase()[SectionForAddress->VirtualAddress];
    if ( !VirtualQuery(the_secs[v11].sec_start, &Buffer, 0x30ui64) )
      _report_error(
        "  VirtualQuery failed for %d bytes at address %p",
        v10->Misc.PhysicalAddress,
        the_secs[v11].sec_start);
    if ( ((Buffer.Protect - 4) & 0xFFFFFFFB) != 0
      && ((Buffer.Protect - 64) & 0xFFFFFFBF) != 0
      && !VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &the_secs[v11].old_protect) )
    {
      LastError = GetLastError();
      _report_error("  VirtualProtect failed with code 0x%x", LastError);
    }
    ++maxSections;
  }
  else
  {
    v7 = 0;
    p_sec_start = &the_secs->sec_start;
    while ( addr < *p_sec_start || addr >= &(*p_sec_start)[*((unsigned int *)p_sec_start[1] + 2)] )
    {
      ++v7;
      p_sec_start += 3;
      if ( v7 == maxSections )
        goto LABEL_6;
    }
  }
  memcpy(addr, src, len);
}

//----- (00000000674816D0) ----------------------------------------------------
void __cdecl pei386_runtime_relocator()
{
  signed __int64 v0; // rax
  void *v1; // rsp
  _DWORD *v2; // rbx
  void *v3; // rsp
  __int64 v4; // rdx
  unsigned int *v5; // rbx
  __int64 v6; // rdx
  BYTE *v7; // rax
  BYTE *v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rbx
  int i; // esi
  __int64 v12; // rcx
  int v13; // eax
  BYTE *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  char v18; // [rsp+20h] [rbp-40h] BYREF
  DWORD flOldProtect; // [rsp+2Ch] [rbp-34h] BYREF
  struct _MEMORY_BASIC_INFORMATION src; // [rsp+30h] [rbp-30h] BYREF

  if ( was_init_73980 )
    return;
  was_init_73980 = 1;
  v0 = (24i64 * _mingw_GetSectionCount() + 30) & 0xFFFFFFFFFFFFFFF0ui64;
  v1 = alloca(v0);
  v2 = refptr___RUNTIME_PSEUDO_RELOC_LIST__;
  v3 = alloca(v0);
  maxSections = 0;
  the_secs = (sSecInfo *)&v18;
  if ( (_BYTE *)refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - (_BYTE *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ <= 7 )
    return;
  if ( (_BYTE *)refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - (_BYTE *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ > 11 )
  {
    if ( *(_DWORD *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ || *((_DWORD *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ + 1) )
      goto LABEL_25;
    if ( *((_DWORD *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ + 2) )
      goto LABEL_11;
    v2 = (char *)refptr___RUNTIME_PSEUDO_RELOC_LIST__ + 12;
  }
  if ( *v2 || v2[1] )
  {
LABEL_25:
    if ( v2 >= refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
      return;
    do
    {
      v12 = (unsigned int)v2[1];
      v13 = *v2;
      v2 += 2;
      v14 = &refptr___image_base__[v12];
      LODWORD(src.BaseAddress) = *(_DWORD *)v14 + v13;
      _write_memory_part_0(v14, &src, 4ui64);
    }
    while ( v2 < refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
    goto LABEL_19;
  }
LABEL_11:
  v4 = (unsigned int)v2[2];
  if ( (_DWORD)v4 != 1 )
    _report_error("  Unknown pseudo relocation protocol version %d.\n", v4);
  v5 = v2 + 3;
  if ( v5 < refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
  {
    do
    {
      v6 = *((unsigned __int8 *)v5 + 8);
      v7 = &refptr___image_base__[*v5];
      v8 = &refptr___image_base__[v5[1]];
      v9 = *(_QWORD *)v7;
      if ( (_DWORD)v6 == 16 )
      {
        v16 = *(unsigned __int16 *)v8;
        if ( (v16 & 0x8000u) != 0i64 )
          v16 = *(unsigned __int16 *)v8 | 0xFFFFFFFFFFFF0000ui64;
        src.BaseAddress = (PVOID)(v9 + v16 - (_QWORD)v7);
        _write_memory_part_0(v8, &src, 2ui64);
      }
      else if ( (unsigned int)v6 <= 0x10 )
      {
        if ( (_DWORD)v6 != 8 )
        {
LABEL_35:
          src.BaseAddress = 0i64;
          _report_error("  Unknown pseudo relocation bit size %d.\n", v6);
        }
        v15 = *v8;
        if ( (v15 & 0x80u) != 0i64 )
          v15 = *v8 | 0xFFFFFFFFFFFFFF00ui64;
        src.BaseAddress = (PVOID)(v9 + v15 - (_QWORD)v7);
        _write_memory_part_0(v8, &src, 1ui64);
      }
      else if ( (_DWORD)v6 == 32 )
      {
        v17 = *(unsigned int *)v8;
        if ( (v17 & 0x80000000) != 0i64 )
          v17 = *(unsigned int *)v8 | 0xFFFFFFFF00000000ui64;
        src.BaseAddress = (PVOID)(v9 + v17 - (_QWORD)v7);
        _write_memory_part_0(v8, &src, 4ui64);
      }
      else
      {
        if ( (_DWORD)v6 != 64 )
          goto LABEL_35;
        src.BaseAddress = (PVOID)(*(_QWORD *)v8 + v9 - (_QWORD)v7);
        _write_memory_part_0(v8, &src, 8ui64);
      }
      v5 += 3;
    }
    while ( v5 < refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
LABEL_19:
    v10 = 0i64;
    for ( i = 0; i < maxSections; ++v10 )
    {
      if ( the_secs[v10].old_protect )
      {
        if ( !VirtualQuery(the_secs[v10].sec_start, &src, 0x30ui64) )
          _report_error(
            "  VirtualQuery failed for %d bytes at address %p",
            the_secs[v10].hash->Misc.PhysicalAddress,
            the_secs[v10].sec_start);
        VirtualProtect(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, &flOldProtect);
      }
      ++i;
    }
  }
}
// 674841A0: using guessed type void *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__;
// 674841B0: using guessed type void *refptr___RUNTIME_PSEUDO_RELOC_LIST__;

//----- (00000000674819D0) ----------------------------------------------------
void __cdecl _do_global_dtors()
{
  void (*i)(void); // rax

  for ( i = *_data_start__; i; ++_data_start__ )
  {
    i();
    i = _data_start__[1];
  }
}

//----- (0000000067481A10) ----------------------------------------------------
void __cdecl _do_global_ctors()
{
  int i; // ebx

  i = (*refptr___CTOR_LIST__)[0];
  if ( i == -1 )
  {
    for ( i = 0; (*refptr___CTOR_LIST__)[i + 1]; ++i )
      ;
  }
  for ( ; i; --i )
    ((void (*)(void))(*refptr___CTOR_LIST__)[i])();
  atexit(_do_global_dtors);
}
// 67484190: using guessed type __int64 (*refptr___CTOR_LIST__)[2];

//----- (0000000067481A70) ----------------------------------------------------
void __cdecl _main()
{
  if ( !initialized )
  {
    initialized = 1;
    _do_global_ctors();
  }
}

//----- (0000000067481A90) ----------------------------------------------------
void __cdecl _security_init_cookie()
{
  FT v0; // r12
  __int64 CurrentProcessId; // rbp
  DWORD CurrentThreadId; // edi
  DWORD TickCount; // esi
  LONGLONG v4; // rsi
  UINT_PTR v5; // rax
  FT systime; // [rsp+20h] [rbp-48h] BYREF
  LARGE_INTEGER perfctr; // [rsp+30h] [rbp-38h] BYREF

  systime.ft_scalar = 0i64;
  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    GetSystemTimeAsFileTime((LPFILETIME)&systime);
    v0.ft_scalar = systime.ft_scalar;
    CurrentProcessId = GetCurrentProcessId();
    CurrentThreadId = GetCurrentThreadId();
    TickCount = GetTickCount();
    QueryPerformanceCounter(&perfctr);
    v4 = (TickCount ^ CurrentThreadId ^ perfctr.QuadPart ^ v0.ft_scalar ^ CurrentProcessId) & 0xFFFFFFFFFFFFi64;
    if ( v4 == 0x2B992DDFA232i64 )
    {
      v5 = 0xFFFFD466D2205DCCui64;
      v4 = 0x2B992DDFA233i64;
    }
    else
    {
      v5 = ~v4;
    }
    _security_cookie = v4;
    _security_cookie_complement = v5;
  }
  else
  {
    _security_cookie_complement = ~_security_cookie;
  }
}

//----- (0000000067481B70) ----------------------------------------------------
void __fastcall __noreturn _report_gsfailure(ULONG_PTR StackCookie)
{
  DWORD64 Rip; // rbx
  _RUNTIME_FUNCTION *v3; // r9
  HANDLE CurrentProcess; // rax
  ULONG64 imgBase; // [rsp+48h] [rbp-28h] BYREF
  ULONG64 establisherFrame; // [rsp+50h] [rbp-20h] BYREF
  PVOID hndData; // [rsp+58h] [rbp-18h] BYREF
  UINT_PTR cookie[2]; // [rsp+60h] [rbp-10h]
  char vars8; // [rsp+78h] [rbp+8h] BYREF
  DWORD64 retaddr; // [rsp+88h] [rbp+18h]

  RtlCaptureContext(&GS_ContextRecord);
  Rip = GS_ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(GS_ContextRecord.Rip, &imgBase, 0i64);
  if ( v3 )
  {
    RtlVirtualUnwind(0, imgBase, Rip, v3, &GS_ContextRecord, &hndData, &establisherFrame, 0i64);
  }
  else
  {
    GS_ContextRecord.Rip = retaddr;
    GS_ContextRecord.Rsp = (DWORD64)&vars8;
  }
  GS_ContextRecord.Rcx = StackCookie;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  GS_ExceptionRecord.ExceptionAddress = (PVOID)GS_ContextRecord.Rip;
  cookie[1] = _security_cookie_complement;
  SetUnhandledExceptionFilter(0i64);
  UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&GS_ExceptionPointers);
  CurrentProcess = GetCurrentProcess();
  TerminateProcess(CurrentProcess, 0xC0000409);
  abort();
}

//----- (0000000067481C70) ----------------------------------------------------
int __fastcall _mingw_SEH_error_handler(
        _EXCEPTION_RECORD *ExceptionRecord,
        void *EstablisherFrame,
        _CONTEXT *ContextRecord,
        void *DispatcherContext)
{
  DWORD ExceptionCode; // eax
  _crt_signal_t v5; // rax
  int result; // eax
  _crt_signal_t v7; // rdx
  _crt_signal_t v8; // rax

  ExceptionCode = ExceptionRecord->ExceptionCode;
  if ( ExceptionRecord->ExceptionCode > 0xC0000091 )
  {
    if ( ExceptionCode == -1073741676 )
    {
      v7 = signal(8, 0i64);
      if ( v7 == (_crt_signal_t)1 )
      {
        signal(8, (_crt_signal_t)1);
        return 0;
      }
      goto LABEL_16;
    }
    if ( ExceptionCode > 0xC0000094 )
    {
      if ( ExceptionCode == -1073741675 )
        return 0;
      if ( ExceptionCode != -1073741674 )
        return 1;
      goto LABEL_20;
    }
    if ( ExceptionCode == -1073741678 )
      return 0;
    if ( ExceptionCode != -1073741677 )
      return 1;
  }
  else if ( ExceptionCode < 0xC000008D )
  {
    if ( ExceptionCode == -1073741816 )
      return 0;
    if ( ExceptionCode <= 0xC0000008 )
    {
      if ( ExceptionCode != -2147483646 )
      {
        if ( ExceptionCode == -1073741819 )
        {
          v5 = signal(11, 0i64);
          if ( v5 == (_crt_signal_t)1 )
          {
            signal(11, (_crt_signal_t)1);
            return 0;
          }
          if ( v5 )
          {
            ((void (__fastcall *)(__int64))v5)(11i64);
            return 0;
          }
          return 4;
        }
        return 1;
      }
      return 0;
    }
    if ( ExceptionCode != -1073741795 )
      return ExceptionCode != -1073741684;
LABEL_20:
    v8 = signal(4, 0i64);
    if ( v8 == (_crt_signal_t)1 )
    {
      signal(4, (_crt_signal_t)1);
      return 0;
    }
    if ( v8 )
    {
      ((void (__fastcall *)(__int64))v8)(4i64);
      return 0;
    }
    return 4;
  }
  v7 = signal(8, 0i64);
  if ( v7 == (_crt_signal_t)1 )
  {
    signal(8, (_crt_signal_t)1);
    fpreset();
    return 0;
  }
LABEL_16:
  result = 1;
  if ( v7 )
  {
    ((void (__fastcall *)(__int64))v7)(8i64);
    return 0;
  }
  return result;
}

//----- (0000000067481E20) ----------------------------------------------------
int __cdecl _mingw_init_ehandler()
{
  PBYTE PEImageBase; // rbp
  int result; // eax
  RUNTIME_FUNCTION *v2; // rbx
  size_t v3; // rsi
  UNWIND_INFO *v4; // rdi
  DWORD VirtualAddress; // edx
  DWORD v6; // edx
  DWORD v7; // eax
  PIMAGE_SECTION_HEADER PESectionExec; // rax
  ULONG v9; // edx

  PEImageBase = GetPEImageBase();
  result = was_here_73812;
  if ( !was_here_73812 && PEImageBase )
  {
    was_here_73812 = 1;
    if ( !FindPESectionByName(".pdata") )
    {
      v2 = emu_pdata;
      v3 = 0i64;
      memset(emu_pdata, 0, sizeof(emu_pdata));
      memset(emu_xdata, 0, sizeof(emu_xdata));
      v4 = emu_xdata;
      while ( 1 )
      {
        PESectionExec = FindPESectionExec(v3);
        if ( !PESectionExec )
          break;
        v4->VersionAndFlags = 9;
        v4->AddressOfExceptionHandler = (char *)_mingw_SEH_error_handler - (char *)PEImageBase;
        ++v3;
        VirtualAddress = PESectionExec->VirtualAddress;
        ++v2;
        v2[-1].BeginAddress = VirtualAddress;
        v6 = PESectionExec->Misc.PhysicalAddress + VirtualAddress;
        v7 = (_DWORD)v4++ - (_DWORD)PEImageBase;
        v2[-1].UnwindData = v7;
        v2[-1].EndAddress = v6;
        if ( v3 == 32 )
        {
          v9 = 32;
          goto LABEL_11;
        }
      }
      if ( !v3 )
        return 1;
      v9 = v3;
LABEL_11:
      RtlAddFunctionTable(emu_pdata, v9, (ULONG64)PEImageBase);
    }
    return 1;
  }
  return result;
}

//----- (0000000067481F10) ----------------------------------------------------
int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data)
{
  DWORD ExceptionCode; // eax
  _crt_signal_t v3; // rax
  int result; // eax
  _crt_signal_t v5; // rax
  _crt_signal_t v6; // rax

  ExceptionCode = exception_data->ExceptionRecord->ExceptionCode;
  if ( (ExceptionCode & 0x20FFFFFF) == 541541187 && (exception_data->ExceptionRecord->ExceptionFlags & 1) == 0 )
    return -1;
  if ( ExceptionCode > 0xC0000091 )
  {
    if ( ExceptionCode == -1073741676 )
    {
      v5 = signal(8, 0i64);
      if ( v5 == (_crt_signal_t)1 )
      {
        signal(8, (_crt_signal_t)1);
        return -1;
      }
LABEL_23:
      if ( v5 )
      {
        ((void (__fastcall *)(__int64))v5)(8i64);
        return -1;
      }
      goto LABEL_15;
    }
    if ( ExceptionCode > 0xC0000094 )
    {
      if ( ExceptionCode == -1073741675 )
        return -1;
      if ( ExceptionCode != -1073741674 )
        goto LABEL_15;
      goto LABEL_29;
    }
    if ( ExceptionCode == -1073741678 )
      return -1;
LABEL_20:
    v5 = signal(8, 0i64);
    if ( v5 == (_crt_signal_t)1 )
    {
      signal(8, (_crt_signal_t)1);
      fpreset();
      return -1;
    }
    goto LABEL_23;
  }
  if ( ExceptionCode >= 0xC000008D )
    goto LABEL_20;
  if ( ExceptionCode == -1073741816 )
    return -1;
  if ( ExceptionCode > 0xC0000008 )
  {
    if ( ExceptionCode != -1073741795 )
    {
      if ( ExceptionCode == -1073741684 )
        return -1;
      goto LABEL_15;
    }
LABEL_29:
    v6 = signal(4, 0i64);
    if ( v6 == (_crt_signal_t)1 )
    {
      signal(4, (_crt_signal_t)1);
      return -1;
    }
    if ( v6 )
    {
      ((void (__fastcall *)(__int64))v6)(4i64);
      return -1;
    }
    goto LABEL_15;
  }
  if ( ExceptionCode == -2147483646 )
    return -1;
  if ( ExceptionCode == -1073741819 )
  {
    v3 = signal(11, 0i64);
    if ( v3 == (_crt_signal_t)1 )
    {
      signal(11, (_crt_signal_t)1);
      return -1;
    }
    if ( v3 )
    {
      ((void (__fastcall *)(__int64))v3)(11i64);
      return -1;
    }
  }
LABEL_15:
  result = (int)_mingw_oldexcpt_handler;
  if ( _mingw_oldexcpt_handler )
    return _mingw_oldexcpt_handler(exception_data);
  return result;
}
// 67481FD5: conditional instruction was optimized away because eax.4==C0000093

//----- (00000000674820D0) ----------------------------------------------------
BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  if ( dwReason && dwReason != 3 )
    return 1;
  _mingw_TLScallback(hDllHandle, dwReason, lpreserved);
  return 1;
}

//----- (0000000067482100) ----------------------------------------------------
BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  if ( *refptr__CRT_MT != 2 )
    *refptr__CRT_MT = 2;
  if ( dwReason == 1 )
    _mingw_TLScallback(hDllHandle, 1u, lpreserved);
  return 1;
}
// 67484180: using guessed type int *refptr__CRT_MT;

//----- (0000000067482170) ----------------------------------------------------
int __fastcall _tlregdtor(_PVFV func)
{
  return 0;
}

//----- (0000000067482180) ----------------------------------------------------
_onexit_t __fastcall mingw_onexit(_onexit_t func)
{
  int (*v2)(void); // rbx
  _PVFV *onexitbegin; // [rsp+20h] [rbp-18h] BYREF
  _PVFV *onexitend; // [rsp+28h] [rbp-10h] BYREF

  onexitbegin = (_PVFV *)decode_pointer(_onexitbegin);
  if ( onexitbegin == (_PVFV *)-1i64 )
    return (_onexit_t)(*(__int64 (__fastcall **)(_onexit_t))refptr___imp__onexit)(func);
  lock(8i64);
  onexitbegin = (_PVFV *)decode_pointer(_onexitbegin);
  onexitend = (_PVFV *)decode_pointer(_onexitend);
  v2 = (int (*)(void))_dllonexit(func, &onexitbegin, &onexitend);
  _onexitbegin = (_PVFV *)encode_pointer(onexitbegin);
  _onexitend = (_PVFV *)encode_pointer(onexitend);
  unlock(8i64);
  return v2;
}
// 674828F8: using guessed type __int64 __fastcall lock(_QWORD);
// 67482900: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD);
// 67482908: using guessed type __int64 __fastcall unlock(_QWORD);
// 674841E0: using guessed type void *refptr___imp__onexit;

//----- (0000000067482230) ----------------------------------------------------
int __fastcall atexit(_PVFV func)
{
  return -(mingw_onexit((_onexit_t)func) == 0i64);
}

//----- (0000000067482250) ----------------------------------------------------
WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase)
{
  BYTE *v1; // rcx
  WINBOOL result; // eax

  v1 = &pImageBase[*((int *)pImageBase + 15)];
  result = 0;
  if ( *(_DWORD *)v1 == 17744 )
    return *((_WORD *)v1 + 12) == 523;
  return result;
}

//----- (0000000067482270) ----------------------------------------------------
WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase)
{
  if ( *(_WORD *)pImageBase == 23117 )
    return ValidateImageBase_part_0(pImageBase);
  else
    return 0;
}

//----- (0000000067482290) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva)
{
  BYTE *v2; // rcx
  PIMAGE_SECTION_HEADER result; // rax
  int v4; // ecx
  _IMAGE_SECTION_HEADER *v5; // r9

  v2 = &pImageBase[*((int *)pImageBase + 15)];
  result = (PIMAGE_SECTION_HEADER)&v2[*((unsigned __int16 *)v2 + 10) + 24];
  v4 = *((unsigned __int16 *)v2 + 3);
  if ( !v4 )
    return 0i64;
  v5 = &result[(unsigned int)(v4 - 1) + 1];
  while ( result->VirtualAddress > rva || rva >= result->Misc.PhysicalAddress + result->VirtualAddress )
  {
    if ( ++result == v5 )
      return 0i64;
  }
  return result;
}

//----- (00000000674822E0) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName)
{
  BYTE *v3; // rdx
  _IMAGE_SECTION_HEADER *v4; // rbx
  int v5; // edx
  __int64 v6; // rdi

  if ( strlen(pName) > 8 )
    return 0i64;
  if ( *(_WORD *)refptr___image_base__ != 23117 )
    return 0i64;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0i64;
  v3 = &refptr___image_base__[*((int *)refptr___image_base__ + 15)];
  v4 = (_IMAGE_SECTION_HEADER *)&v3[*((unsigned __int16 *)v3 + 10) + 24];
  v5 = *((unsigned __int16 *)v3 + 3);
  if ( !v5 )
    return 0i64;
  v6 = (__int64)&v4[(unsigned int)(v5 - 1) + 1];
  while ( strncmp((const char *)v4, pName, 8ui64) )
  {
    if ( ++v4 == (_IMAGE_SECTION_HEADER *)v6 )
      return 0i64;
  }
  return v4;
}

//----- (0000000067482380) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p)
{
  if ( *(_WORD *)refptr___image_base__ == 23117 && ValidateImageBase_part_0(refptr___image_base__) )
    return FindPESection(refptr___image_base__, (_BYTE *)p - refptr___image_base__);
  else
    return 0i64;
}

//----- (00000000674823D0) ----------------------------------------------------
int __cdecl _mingw_GetSectionCount()
{
  int result; // eax

  result = 0;
  if ( *(_WORD *)refptr___image_base__ == 23117 )
  {
    result = ValidateImageBase_part_0(refptr___image_base__);
    if ( result )
      return *(unsigned __int16 *)&refptr___image_base__[*((int *)refptr___image_base__ + 15) + 6];
  }
  return result;
}

//----- (0000000067482410) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo)
{
  BYTE *v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rax

  if ( *(_WORD *)refptr___image_base__ != 23117 )
    return 0i64;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0i64;
  v3 = &refptr___image_base__[*((int *)refptr___image_base__ + 15)];
  v4 = (__int64)&v3[*((unsigned __int16 *)v3 + 10) + 24];
  if ( !*((_WORD *)v3 + 3) )
    return 0i64;
  v5 = v4 + 40i64 * ((unsigned int)*((unsigned __int16 *)v3 + 3) - 1) + 40;
  while ( (*(_BYTE *)(v4 + 39) & 0x20) == 0 )
  {
LABEL_9:
    v4 += 40i64;
    if ( v4 == v5 )
      return 0i64;
  }
  if ( eNo )
  {
    --eNo;
    goto LABEL_9;
  }
  return (PIMAGE_SECTION_HEADER)v4;
}

//----- (00000000674824A0) ----------------------------------------------------
PBYTE __cdecl GetPEImageBase()
{
  BYTE *v0; // rbx

  v0 = 0i64;
  if ( *(_WORD *)refptr___image_base__ != 23117 )
    return 0i64;
  if ( ValidateImageBase_part_0(refptr___image_base__) )
    return refptr___image_base__;
  return v0;
}

//----- (00000000674824E0) ----------------------------------------------------
WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget)
{
  WINBOOL result; // eax
  PIMAGE_SECTION_HEADER PESection; // rax

  result = 0;
  if ( *(_WORD *)refptr___image_base__ == 23117 )
  {
    result = ValidateImageBase_part_0(refptr___image_base__);
    if ( result )
    {
      PESection = FindPESection(refptr___image_base__, pTarget - refptr___image_base__);
      return PESection && (PESection->Characteristics & 0x80000000) == 0;
    }
  }
  return result;
}

//----- (0000000067482540) ----------------------------------------------------
const char *__fastcall _mingw_enum_import_library_names(int i)
{
  unsigned int v3; // edx
  __int64 v4; // rbx
  BYTE *v5; // rdx

  if ( *(_WORD *)refptr___image_base__ != 23117 )
    return 0i64;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0i64;
  v3 = *(_DWORD *)&refptr___image_base__[*((int *)refptr___image_base__ + 15) + 144];
  if ( !v3 )
    return 0i64;
  v4 = v3;
  if ( !FindPESection(refptr___image_base__, v3) )
    return 0i64;
  v5 = &refptr___image_base__[v4];
  if ( !&refptr___image_base__[v4] )
    return 0i64;
  while ( *((_DWORD *)v5 + 1) || *((_DWORD *)v5 + 3) )
  {
    if ( i <= 0 )
      return (const char *)&refptr___image_base__[*((unsigned int *)v5 + 3)];
    --i;
    v5 += 20;
  }
  return 0i64;
}

//----- (00000000674825F0) ----------------------------------------------------
void __cdecl fpreset()
{
  __asm { fninit }
}

//----- (0000000067482600) ----------------------------------------------------
void __cdecl _mingwthr_run_key_dtors_part_0()
{
  volatile __mingwthr_key_t *i; // rbx
  LPVOID Value; // rsi

  EnterCriticalSection(&_mingwthr_cs);
  for ( i = key_dtor_list; i; i = i->next )
  {
    Value = TlsGetValue(i->key);
    if ( !GetLastError() && Value )
      i->dtor(Value);
  }
  LeaveCriticalSection(&_mingwthr_cs);
}

//----- (0000000067482670) ----------------------------------------------------
int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *))
{
  int result; // eax
  volatile __mingwthr_key_t *v5; // rax
  volatile __mingwthr_key_t *v6; // rbx
  volatile __mingwthr_key_t *v7; // rax

  result = _mingwthr_cs_init;
  if ( _mingwthr_cs_init )
  {
    v5 = (volatile __mingwthr_key_t *)calloc(1ui64, 0x18ui64);
    v6 = v5;
    if ( v5 )
    {
      v5->key = key;
      v5->dtor = dtor;
      EnterCriticalSection(&_mingwthr_cs);
      v7 = key_dtor_list;
      key_dtor_list = v6;
      v6->next = v7;
      LeaveCriticalSection(&_mingwthr_cs);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (00000000674826F0) ----------------------------------------------------
int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key)
{
  volatile __mingwthr_key_t *v3; // rdx
  volatile __mingwthr_key_t *next; // rax
  volatile __mingwthr_key_t *v5; // rcx

  if ( !_mingwthr_cs_init )
    return 0;
  EnterCriticalSection(&_mingwthr_cs);
  v3 = key_dtor_list;
  if ( key_dtor_list )
  {
    if ( key_dtor_list->key == key )
    {
      v5 = key_dtor_list;
      key_dtor_list = key_dtor_list->next;
LABEL_12:
      free((void *)v5);
      LeaveCriticalSection(&_mingwthr_cs);
      return 0;
    }
    while ( 1 )
    {
      next = v3->next;
      if ( !next )
        break;
      if ( next->key == key )
      {
        v5 = v3->next;
        v3->next = next->next;
        goto LABEL_12;
      }
      v3 = v3->next;
    }
  }
  LeaveCriticalSection(&_mingwthr_cs);
  return 0;
}

//----- (0000000067482790) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved)
{
  WINBOOL result; // eax

  if ( reason == 1 )
  {
    if ( !_mingwthr_cs_init )
      InitializeCriticalSection(&_mingwthr_cs);
    result = 1;
    _mingwthr_cs_init = 1;
  }
  else
  {
    if ( reason )
    {
      if ( reason == 3 )
      {
        if ( _mingwthr_cs_init )
          _mingwthr_run_key_dtors_part_0();
      }
    }
    else
    {
      if ( _mingwthr_cs_init )
        _mingwthr_run_key_dtors_part_0();
      if ( _mingwthr_cs_init == 1 )
      {
        _mingwthr_cs_init = 0;
        _IAT_start__(&_mingwthr_cs, *(_QWORD *)&reason, reserved);
      }
    }
    return 1;
  }
  return result;
}
// 67482790: variables would overlap: edx.4 and rdx.8
// 6748919C: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD);

//----- (0000000067482870) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  return 1;
}

//----- (0000000067482880) ----------------------------------------------------
BOOL __fastcall DllEntryPoint(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  return 1;
}

// nfuncs=83 queued=38 decompiled=38 lumina nreq=0 worse=0 better=0
// ALL OK, 38 function(s) have been successfully decompiled
int64_t pre_c_init()
{
    int64_t* rax = malloc(0x100);
    int64_t rax_1 = _encode_pointer(rax);
    __onexitbegin = rax_1;
    __onexitend = rax_1;
    if (rax == 0)
    {
        return 1;
    }
    *rax = 0;
    return 0;
}

int64_t _CRT_INIT(int64_t arg1, int32_t arg2)
{
    int64_t rax_2;
    if (arg2 != 0)
    {
        rax_2 = 1;
        if (arg2 == 1)
        {
            void* gsbase;
            int64_t rsi_1 = *(*(gsbase + 0x30) + 8);
            int32_t rsi_2;
            while (true)
            {
                int64_t __native_startup_lock_2 = 0;
                if (0 == __native_startup_lock)
                {
                    __native_startup_lock = rsi_1;
                }
                else
                {
                    __native_startup_lock_2 = __native_startup_lock;
                }
                if (__native_startup_lock_2 == 0)
                {
                    rsi_2 = 0;
                    break;
                }
                if (rsi_1 == __native_startup_lock_2)
                {
                    rsi_2 = 1;
                    break;
                }
                Sleep(0x3e8);
            }
            if (__native_startup_state == 1)
            {
                _amsg_exit(0x1f);
            }
            else if (__native_startup_state == 0)
            {
                __native_startup_state = 1;
                _initterm(&__xi_a, &__xi_z);
            }
            if (__native_startup_state == 1)
            {
                _initterm(&__xc_a, &__xc_z);
                __native_startup_state = 2;
            }
            if (rsi_2 == 0)
            {
                __native_startup_lock;
                __native_startup_lock = 0;
            }
            _TLS_Entry_0(arg1, 2);
            __bss_start__ = (__bss_start__ + 1);
            return 1;
        }
    }
    else
    {
        int32_t __bss_start___1 = __bss_start__;
        if (__bss_start___1 <= 0)
        {
            rax_2 = 0;
        }
        else
        {
            __bss_start__ = (__bss_start___1 - 1);
            while (true)
            {
                int64_t __native_startup_lock_1 = 0;
                if (0 == __native_startup_lock)
                {
                    __native_startup_lock = 1;
                }
                else
                {
                    __native_startup_lock_1 = __native_startup_lock;
                }
                if (__native_startup_lock_1 == 0)
                {
                    break;
                }
                Sleep(0x3e8);
            }
            if (__native_startup_state == 2)
            {
                int64_t rax_8 = _decode_pointer(__onexitbegin);
                if (rax_8 != 0)
                {
                    int64_t* rsi_3 = _decode_pointer(__onexitend);
                    int64_t i;
                    do
                    {
                        rsi_3 = (rsi_3 - 8);
                        if (rax_8 > rsi_3)
                        {
                            break;
                        }
                        do
                        {
                            i = *rsi_3;
                            if (i == 0)
                            {
                                break;
                            }
                            rsi_3 = (rsi_3 - 8);
                            i();
                        } while (rax_8 <= rsi_3);
                    } while (i == 0);
                    free(rax_8);
                    __onexitend = 0;
                    __onexitbegin = 0;
                }
                __native_startup_state = 0;
                __native_startup_lock = 0;
                return 1;
            }
            _amsg_exit(0x1f);
            rax_2 = 1;
        }
    }
    return rax_2;
}

uint64_t __DllMainCRTStartup(int64_t arg1, int32_t arg2)
{
    __native_dllmain_reason = arg2;
    int32_t rax_3;
    int32_t rsi_1;
    if (arg2 != 0)
    {
        _pei386_runtime_relocator();
        if ((arg2 - 1) <= 1)
        {
            rax_3 = _CRT_INIT(arg1, arg2);
            if (rax_3 != 0)
            {
                rsi_1 = 1;
                if (arg2 != 1)
                {
                    rsi_1 = 1;
                }
            }
        }
    }
    if ((((arg2 - 1) <= 1 && rax_3 != 0) && arg2 == 1))
    {
        __main();
        rsi_1 = 1;
    }
    if ((arg2 == 0 && __bss_start__ != 0))
    {
        _pei386_runtime_relocator();
    }
    if (((arg2 == 0 && __bss_start__ != 0) || (arg2 != 0 && (arg2 - 1) > 1)))
    {
        rsi_1 = 1;
    }
    if ((((arg2 == 0 && __bss_start__ != 0) || (arg2 != 0 && (arg2 - 1) > 1)) || (((arg2 != 0 && (arg2 - 1) <= 1) && rax_3 != 0) && arg2 != 1)))
    {
        if (arg2 == 3)
        {
        label_67481329:
            rsi_1 = 1;
            if (_CRT_INIT(arg1, arg2) == 0)
            {
                rsi_1 = 0;
            }
        }
        else if (arg2 == 0)
        {
            goto label_67481329;
        }
    }
    if (((arg2 == 0 && __bss_start__ == 0) || ((arg2 != 0 && (arg2 - 1) <= 1) && rax_3 == 0)))
    {
        rsi_1 = 0;
    }
    __native_dllmain_reason = 0xffffffff;
    return rsi_1;
}

int64_t _start(int64_t arg1, int32_t arg2)
{
    mingw_app_type = 0;
    if (arg2 == 1)
    {
        __security_init_cookie();
        __mingw_init_ehandler();
        /* tailcall */
        return __DllMainCRTStartup(arg1, arg2);
    }
    /* tailcall */
    return __DllMainCRTStartup(arg1, arg2);
}

int64_t* readExpression(int64_t* arg1)
{
    fflush(__iob_func());
    printf("Enter the expression (e.g. + 1/4…");
    int64_t var_28;
    int64_t var_20;
    int32_t var_18;
    scanf("%c %d/%d  %d/%d", &var_28, &*var_28[4], &var_20, &*var_20[4], &var_18);
    fflush(__iob_func());
    *arg1 = var_28;
    arg1[1] = var_20;
    arg1[2] = var_18;
    return arg1;
}

int64_t _decode_pointer(int64_t arg1) __pure
{
    return arg1;
}

int64_t _encode_pointer(int64_t arg1) __pure
{
    return arg1;
}

int64_t __report_error(char* arg1, int64_t arg2) __noreturn
{
    _ArgList = arg2;
    int64_t r8;
    arg_18 = r8;
    int64_t r9;
    arg_20 = r9;
    fwrite("Mingw-w64 runtime failure:\n", 1, 0x1b, &__iob_func()[0xc]);
    vfprintf(&__iob_func()[0xc], arg1, &_ArgList);
    abort();
    /* no return */
}

int64_t __write_memory.part.0(int64_t arg1, int64_t arg2, uint64_t arg3)
{
    int64_t maxSections_1 = maxSections;
    int64_t* rax_2;
    int64_t r10_1;
    if (maxSections_1 <= 0)
    {
        maxSections_1 = 0;
    }
    else
    {
        int32_t i = 0;
        rax_2 = (the_secs + 8);
        do
        {
            r10_1 = *rax_2;
            if ((arg1 >= r10_1 && arg1 < (r10_1 + *(rax_2[1] + 8))))
            {
                break;
            }
            i = (i + 1);
            rax_2 = &rax_2[3];
        } while (i != maxSections_1);
    }
    if ((maxSections_1 <= 0 || (maxSections_1 > 0 && (!(arg1 >= r10_1 && arg1 < (r10_1 + *(rax_2[1] + 8)))))))
    {
        void* rax_3 = __mingw_GetSectionForAddress(arg1);
        if (rax_3 == 0)
        {
            __report_error("Address %p has no image-section", arg1);
            /* no return */
        }
        int64_t rbp_1 = (maxSections_1 * 0x18);
        int32_t* r13_2 = (rbp_1 + the_secs);
        *(r13_2 + 0x10) = rax_3;
        *r13_2 = 0;
        *(r13_2 + 8) = (_GetPEImageBase() + *(rax_3 + 0xc));
        void* var_68;
        if (VirtualQuery(*((the_secs + rbp_1) + 8), &var_68, 0x30) == 0)
        {
            *((the_secs + rbp_1) + 8);
            __report_error("  VirtualQuery failed for %d byt…", *(rax_3 + 8));
            /* no return */
        }
        uint64_t* dwSize;
        int32_t var_44;
        if (((((var_44 - 4) & 0xfffffffb) != 0 && ((var_44 - 0x40) & 0xffffffbf) != 0) && VirtualProtect(var_68, dwSize, PAGE_EXECUTE_READWRITE, (rbp_1 + the_secs)) == 0))
        {
            __report_error("  VirtualProtect failed with cod…", GetLastError());
            /* no return */
        }
        maxSections = (maxSections + 1);
    }
    /* tailcall */
    return memcpy(arg1, arg2, arg3);
}

void _pei386_runtime_relocator()
{
    if (_.bss == 0)
    {
        _.bss = 1;
        void* rax_5 = (((__mingw_GetSectionCount() * 0x18) + 0x1e) & 0xfffffffffffffff0);
        ___chkstk_ms(rax_5);
        maxSections = 0;
        void var_98;
        the_secs = ((&var_98 - rax_5) + 0x20);
    }
}

int64_t __do_global_dtors()
{
    int64_t i = **&__data_start__;
    if (i != 0)
    {
        do
        {
            i();
            void* __data_start___1 = __data_start__;
            i = *(__data_start___1 + 8);
            __data_start__ = (__data_start___1 + 8);
        } while (i != 0);
    }
    return i;
}

int64_t __do_global_ctors()
{
    int32_t i_1 = 0;
    while (true)
    {
        uint64_t rdx_2 = (i_1 + 1);
        if (*(0x674829e0 + (rdx_2 << 3)) == 0)
        {
            break;
        }
        i_1 = rdx_2;
    }
    if (i_1 != 0)
    {
        int32_t i;
        do
        {
            *(0x674829e0 + (i_1 << 3))();
            i = i_1;
            i_1 = (i_1 - 1);
        } while (i != 1);
    }
    /* tailcall */
    return atexit(__do_global_dtors);
}

uint64_t __main()
{
    uint64_t _.bss_1 = _.bss;
    if (_.bss_1 == 0)
    {
        _.bss = 1;
        /* tailcall */
        return __do_global_ctors();
    }
    return _.bss_1;
}

void __security_init_cookie()
{
    int64_t __security_cookie_1 = __security_cookie;
    int64_t lpSystemTimeAsFileTime = 0;
    if (__security_cookie_1 != 0x2b992ddfa232)
    {
        __security_cookie_complement = (!__security_cookie_1);
        return;
    }
    GetSystemTimeAsFileTime(&lpSystemTimeAsFileTime);
    int64_t lpSystemTimeAsFileTime_1 = lpSystemTimeAsFileTime;
    uint64_t rbp = GetCurrentProcessId();
    uint32_t rax_1 = GetCurrentThreadId();
    uint32_t rax_2 = GetTickCount();
    int64_t lpPerformanceCount;
    QueryPerformanceCounter(&lpPerformanceCount);
    int64_t rsi_2 = ((((rbp ^ (lpSystemTimeAsFileTime_1 ^ lpPerformanceCount)) ^ rax_1) ^ rax_2) & 0xffffffffffff);
    int64_t rax_4;
    if (rsi_2 == __security_cookie_1)
    {
        rax_4 = -0x2b992ddfa234;
        rsi_2 = 0x2b992ddfa233;
    }
    else
    {
        rax_4 = (!rsi_2);
    }
    __security_cookie = rsi_2;
    __security_cookie_complement = rax_4;
}

int64_t __report_gsfailure(int64_t arg1) __noreturn
{
    int64_t rsi;
    int64_t var_10 = rsi;
    RtlCaptureContext(&_.bss);
    uint64_t ControlPc = data_67487138;
    uint64_t ImageBase;
    struct IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, nullptr);
    void EstablisherFrame;
    void HandlerData;
    if (FunctionEntry == 0)
    {
        data_67487138 = __return_addr;
        data_674870d8 = &var_10;
    }
    else
    {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER, ImageBase, ControlPc, FunctionEntry, &_.bss, &HandlerData, &EstablisherFrame, nullptr);
    }
    int64_t rax = data_67487138;
    data_674870c0 = arg1;
    GS_ExceptionRecord = 0xc0000409;
    data_67487544 = 1;
    data_67487550 = rax;
    int64_t __security_cookie_1 = __security_cookie;
    int64_t __security_cookie_complement_1 = __security_cookie_complement;
    SetUnhandledExceptionFilter(nullptr);
    UnhandledExceptionFilter(&_.rdata);
    TerminateProcess(GetCurrentProcess(), 0xc0000409);
    abort();
    /* no return */
}

int64_t __mingw_SEH_error_handler(int32_t* arg1)
{
    int32_t rax = *arg1;
    int64_t rax_2;
    _crt_signal_t rdx_1;
    if (rax == 0xc0000094)
    {
        _crt_signal_t rax_8 = signal(8, nullptr);
        rdx_1 = rax_8;
        if (rax_8 == 1)
        {
            signal(8, 1);
            rax_2 = 0;
        label_67481cd7:
            return rax_2;
        }
    }
    if ((rax > 0xc0000091 && rax != 0xc0000094))
    {
        if (rax > 0xc0000094)
        {
            if (rax == 0xc0000095)
            {
                goto label_67481da6;
            }
            if (rax != 0xc0000096)
            {
            label_67481d87:
                return 1;
            }
        label_67481d45:
            _crt_signal_t rax_5 = signal(4, nullptr);
            if (rax_5 == 1)
            {
                signal(4, 1);
                rax_2 = 0;
                goto label_67481cd7;
            }
            if (rax_5 != 0)
            {
                rax_5(4);
                rax_2 = 0;
                goto label_67481cd7;
            }
        label_67481de9:
            return 4;
        }
        if (rax == 0xc0000092)
        {
            goto label_67481da6;
        }
        if (rax != 0xc0000093)
        {
            goto label_67481d87;
        }
    }
    if ((rax <= 0xc0000091 && rax < 0xc000008d))
    {
        if (rax == 0xc0000008)
        {
            goto label_67481da6;
        }
        if (rax > 0xc0000008)
        {
            if (rax != 0xc000001d)
            {
                if (rax == 0xc000008c)
                {
                    goto label_67481da6;
                }
                goto label_67481d87;
            }
            goto label_67481d45;
        }
        if (rax == 0x80000002)
        {
            goto label_67481da6;
        }
        if (rax != 0xc0000005)
        {
            goto label_67481d87;
        }
        _crt_signal_t rax_1 = signal(0xb, nullptr);
        if (rax_1 == 1)
        {
            signal(0xb, 1);
            rax_2 = 0;
            goto label_67481cd7;
        }
        if (rax_1 != 0)
        {
            rax_1(0xb);
            rax_2 = 0;
            goto label_67481cd7;
        }
        goto label_67481de9;
    }
    if (((rax > 0xc0000091 && rax != 0xc0000094) || rax <= 0xc0000091))
    {
        _crt_signal_t rax_3 = signal(8, nullptr);
        rdx_1 = rax_3;
        if (rax_3 == 1)
        {
            signal(8, 1);
        label_67481da6:
            return 0;
        }
    }
    rax_2 = 1;
    if (rdx_1 != 0)
    {
        rdx_1(8);
        return 0;
    }
    goto label_67481cd7;
}

uint64_t __mingw_init_ehandler()
{
    uint64_t BaseAddress = _GetPEImageBase();
    uint64_t was_here.73812_1 = was_here.73812;
    if ((was_here.73812_1 == 0 && BaseAddress != 0))
    {
        was_here.73812 = 1;
        char* rax = _FindPESectionByName(".pdata");
        if (rax == 0)
        {
            void* rbx_1 = &emu_pdata;
            int64_t rsi_1 = 0;
            int64_t rcx_1;
            int64_t rdi_1;
            rdi_1 = __memfill_u64(&emu_pdata, rax, 0x180);
            rcx_1 = 0x20;
            int64_t rcx_2;
            int64_t rdi_2;
            rdi_2 = __memfill_u64(&emu_xdata, rax, (rcx_1 << 3));
            void* rdi_3 = &emu_xdata;
            while (true)
            {
                void* rax_3 = _FindPESectionExec(rsi_1);
                uint32_t EntryCount;
                if (rax_3 != 0)
                {
                    *rdi_3 = 9;
                    *(rdi_3 + 4) = (0x67481c70 - BaseAddress);
                    rsi_1 = (rsi_1 + 1);
                    int32_t rdx_1 = *(rax_3 + 0xc);
                    rbx_1 = (rbx_1 + 0xc);
                    *(rbx_1 - 0xc) = rdx_1;
                    int32_t rdx_2 = (rdx_1 + *(rax_3 + 8));
                    int32_t rax_2 = (rdi_3 - BaseAddress);
                    rdi_3 = (rdi_3 + 8);
                    *(rbx_1 - 4) = rax_2;
                    *(rbx_1 - 8) = rdx_2;
                    if (rsi_1 != 0x20)
                    {
                        continue;
                    }
                    else
                    {
                        EntryCount = 0x20;
                    }
                }
                else
                {
                    if (rsi_1 == 0)
                    {
                        break;
                    }
                    EntryCount = rsi_1;
                }
                RtlAddFunctionTable(&emu_pdata, EntryCount, BaseAddress);
                break;
            }
        }
        was_here.73812_1 = 1;
    }
    return was_here.73812_1;
}

int64_t _gnu_exception_handler(int64_t* arg1)
{
    int32_t* rdx = *arg1;
    int32_t rax = *rdx;
    if (((rax & 0x20ffffff) == 0x20474343 && (rdx[1] & 1) == 0))
    {
        goto label_67481f83;
    }
    int64_t __mingw_oldexcpt_handler_1;
    _crt_signal_t rax_2;
    if (rax == 0xc0000094)
    {
        rax_2 = signal(8, nullptr);
        if (rax_2 == 1)
        {
            signal(8, 1);
        label_67481f83:
            __mingw_oldexcpt_handler_1 = 0xffffffff;
        }
    }
    if ((rax > 0xc0000091 && rax != 0xc0000094))
    {
        if (rax > 0xc0000094)
        {
            if (rax == 0xc0000095)
            {
                goto label_67481f83;
            }
            if (rax != 0xc0000096)
            {
                goto label_67481fa2;
            }
        }
        else
        {
            if (rax == 0xc0000092)
            {
                goto label_67481f83;
            }
            if (rax != 0xc0000093)
            {
                goto label_67481fa2;
            }
        }
    }
    if (((rax <= 0xc0000091 && rax >= 0xc000008d) || ((rax > 0xc0000091 && rax != 0xc0000094) && rax <= 0xc0000094)))
    {
        rax_2 = signal(8, nullptr);
        if (rax_2 == 1)
        {
            signal(8, 1);
            goto label_67481f83;
        }
    }
    if ((((rax == 0xc0000094 && rax_2 != 1) || (rax <= 0xc0000091 && rax >= 0xc000008d)) || ((rax > 0xc0000091 && rax != 0xc0000094) && rax <= 0xc0000094)))
    {
        if (rax_2 != 0)
        {
            rax_2(8);
            __mingw_oldexcpt_handler_1 = 0xffffffff;
        }
        else
        {
        label_67481fa2:
            __mingw_oldexcpt_handler_1 = __mingw_oldexcpt_handler;
            if (__mingw_oldexcpt_handler_1 != 0)
            {
                /* jump -> __mingw_oldexcpt_handler_1 */
            }
        }
    }
    if ((rax <= 0xc0000091 && rax < 0xc000008d))
    {
        if (rax == 0xc0000008)
        {
            goto label_67481f83;
        }
        if (rax <= 0xc0000008)
        {
            if (rax == 0x80000002)
            {
                goto label_67481f83;
            }
            if (rax != 0xc0000005)
            {
                goto label_67481fa2;
            }
            _crt_signal_t rax_1 = signal(0xb, nullptr);
            if (rax_1 == 1)
            {
                signal(0xb, 1);
                goto label_67481f83;
            }
            if (rax_1 == 0)
            {
                goto label_67481fa2;
            }
            rax_1(0xb);
            goto label_67481f83;
        }
        if (rax != 0xc000001d)
        {
            if (rax == 0xc000008c)
            {
                goto label_67481f83;
            }
            goto label_67481fa2;
        }
    }
    if ((((rax > 0xc0000091 && rax != 0xc0000094) && rax > 0xc0000094) || (rax <= 0xc0000091 && rax < 0xc000008d)))
    {
        _crt_signal_t rax_3 = signal(4, nullptr);
        if (rax_3 == 1)
        {
            signal(4, 1);
            goto label_67481f83;
        }
        if (rax_3 == 0)
        {
            goto label_67481fa2;
        }
        rax_3(4);
        __mingw_oldexcpt_handler_1 = 0xffffffff;
    }
    return __mingw_oldexcpt_handler_1;
}

int64_t _TLS_Entry_1(int64_t arg1, int32_t arg2)
{
    if ((arg2 != 0 && arg2 != 3))
    {
        return 1;
    }
    __mingw_TLScallback(arg1, arg2);
    return 1;
}

int64_t _TLS_Entry_0(int64_t arg1, int32_t arg2)
{
    if (_CRT_MT != 2)
    {
        _CRT_MT = 2;
    }
    if (arg2 == 2)
    {
        /* nop */
    }
    else if (arg2 == 1)
    {
        __mingw_TLScallback(arg1, arg2);
    }
    return 1;
}

int64_t __tlregdtor() __pure
{
    return 0;
}

_onexit_t mingw_onexit(_onexit_t arg1)
{
    int64_t pbegin_1 = _decode_pointer(__onexitbegin);
    int64_t pbegin = pbegin_1;
    if (pbegin_1 == -1)
    {
        return _onexit(arg1);
    }
    _lock(8);
    int64_t pbegin_2 = _decode_pointer(__onexitbegin);
    int64_t __onexitend_1 = __onexitend;
    pbegin = pbegin_2;
    _PVFV* pend = _decode_pointer(__onexitend_1);
    _onexit_t rax_1 = __dllonexit(arg1, &pbegin, &pend);
    int64_t rax_2 = _encode_pointer(pbegin);
    _PVFV* pend_1 = pend;
    __onexitbegin = rax_2;
    __onexitend = _encode_pointer(pend_1);
    _unlock(8);
    return rax_1;
}

uint64_t atexit(_onexit_t arg1)
{
    _onexit_t rax;
    rax = mingw_onexit(arg1) == 0;
    return (-rax);
}

int64_t _ValidateImageBase.part.0(void* arg1)
{
    void* rcx = (arg1 + *(arg1 + 0x3c));
    if (*rcx == 0x4550)
    {
        int64_t rax_1;
        rax_1 = *(rcx + 0x18) == 0x20b;
        return rax_1;
    }
    return 0;
}

int64_t _ValidateImageBase(int16_t* arg1)
{
    if (*arg1 == 0x5a4d)
    {
        /* tailcall */
        return _ValidateImageBase.part.0(arg1);
    }
    return 0;
}

void* _FindPESection(void* arg1, int64_t arg2)
{
    void* rcx = (arg1 + *(arg1 + 0x3c));
    void* rax_1 = ((rcx + *(rcx + 0x14)) + 0x18);
    uint32_t rcx_1 = *(rcx + 6);
    if (rcx_1 != 0)
    {
        void* r9_1 = ((rax_1 + ((rcx_1 - 1) * 0x28)) + 0x28);
        do
        {
            uint64_t r8_1 = *(rax_1 + 0xc);
            if ((r8_1 <= arg2 && arg2 < (r8_1 + *(rax_1 + 8))))
            {
                return rax_1;
            }
            rax_1 = (rax_1 + 0x28);
        } while (rax_1 != r9_1);
    }
    return nullptr;
}

char* _FindPESectionByName(char* arg1)
{
    if (strlen(arg1) <= 8)
    {
        if (_ValidateImageBase.part.0(&__dos_header) == 0)
        {
            return 0;
        }
        char* _Str1 = &__section_headers;
        do
        {
            if (strncmp(_Str1, arg1, 8) == 0)
            {
                return _Str1;
            }
            _Str1 = &_Str1[0x28];
        } while (_Str1 != 0x67480480);
    }
    return 0;
}

int64_t __mingw_GetSectionForAddress(int64_t arg1)
{
    if (_ValidateImageBase.part.0(&__dos_header) != 0)
    {
        /* tailcall */
        return _FindPESection(&__dos_header, (arg1 - 0x67480000));
    }
    return 0;
}

int64_t __mingw_GetSectionCount()
{
    int64_t rax = _ValidateImageBase.part.0(&__dos_header);
    if (rax != 0)
    {
        return 0x13;
    }
    return rax;
}

void* _FindPESectionExec(int64_t arg1)
{
    int64_t rbx = arg1;
    if (_ValidateImageBase.part.0(&__dos_header) == 0)
    {
        return 0;
    }
    void* i = &__section_headers;
    do
    {
        if ((*(i + 0x27) & 0x20) != 0)
        {
            if (rbx == 0)
            {
                return i;
            }
            rbx = (rbx - 1);
        }
        i = (i + 0x28);
    } while (i != 0x67480480);
    return 0;
}

int64_t _GetPEImageBase()
{
    int64_t rbx = 0;
    if (_ValidateImageBase.part.0(&__dos_header) != 0)
    {
        rbx = 0x67480000;
    }
    return rbx;
}

uint64_t _IsNonwritableInCurrentImage(int64_t arg1)
{
    int64_t rax = _ValidateImageBase.part.0(&__dos_header);
    if (rax != 0)
    {
        void* rax_1 = _FindPESection(&__dos_header, (arg1 - 0x67480000));
        if (rax_1 != 0)
        {
            return ((!*(rax_1 + 0x24)) >> 0x1f);
        }
        rax = 0;
    }
    return rax;
}

int64_t __mingw_enum_import_library_names(int32_t arg1)
{
    int32_t rsi = arg1;
    if ((_ValidateImageBase.part.0(&__dos_header) != 0 && _FindPESection(&__dos_header, 0x9000) != 0))
    {
        void* rdx_1 = &_head_lib64_libkernel32_a;
        while (true)
        {
            if ((*(rdx_1 + 4) == 0 && *(rdx_1 + 0xc) == 0))
            {
                return 0;
            }
            if (rsi <= 0)
            {
                break;
            }
            rsi = (rsi - 1);
            rdx_1 = (rdx_1 + 0x14);
        }
        return (*(rdx_1 + 0xc) + 0x67480000);
    }
    return 0;
}

int64_t fpreset() __pure
{
    return;
}

int64_t __mingwthr_run_key_dtors.part.0()
{
    EnterCriticalSection(&__mingwthr_cs);
    int32_t* key_dtor_list_1 = key_dtor_list;
    if (key_dtor_list_1 != 0)
    {
        do
        {
            void* rax_1 = TlsGetValue(*key_dtor_list_1);
            if ((GetLastError() == NO_ERROR && rax_1 != 0))
            {
                *(key_dtor_list_1 + 8)(rax_1);
            }
            key_dtor_list_1 = *(key_dtor_list_1 + 0x10);
        } while (key_dtor_list_1 != 0);
    }
    /* tailcall */
    return LeaveCriticalSection(&__mingwthr_cs);
}

uint64_t ___w64_mingwthr_add_key_dtor(int32_t arg1, int64_t arg2)
{
    uint64_t __mingwthr_cs_init_1 = __mingwthr_cs_init;
    if (__mingwthr_cs_init_1 != 0)
    {
        int32_t* rax = calloc(1, 0x18);
        if (rax != 0)
        {
            *rax = arg1;
            *(rax + 8) = arg2;
            EnterCriticalSection(&__mingwthr_cs);
            int64_t key_dtor_list_1 = key_dtor_list;
            key_dtor_list = rax;
            *(rax + 0x10) = key_dtor_list_1;
            LeaveCriticalSection(&__mingwthr_cs);
            return 0;
        }
        __mingwthr_cs_init_1 = 0xffffffff;
    }
    return __mingwthr_cs_init_1;
}

int64_t ___w64_mingwthr_remove_key_dtor(int32_t arg1)
{
    if (__mingwthr_cs_init == 0)
    {
        return 0;
    }
    EnterCriticalSection(&__mingwthr_cs);
    int32_t* key_dtor_list_1 = key_dtor_list;
    int32_t* key_dtor_list_2;
    int32_t* key_dtor_list_3;
    if (key_dtor_list_1 != 0)
    {
        if (*key_dtor_list_1 == arg1)
        {
            key_dtor_list_3 = key_dtor_list_1;
            key_dtor_list = *(key_dtor_list_1 + 0x10);
        }
        else
        {
            while (true)
            {
                key_dtor_list_2 = *(key_dtor_list_1 + 0x10);
                if (key_dtor_list_2 == 0)
                {
                    break;
                }
                if (*key_dtor_list_2 == arg1)
                {
                    break;
                }
                key_dtor_list_1 = key_dtor_list_2;
            }
        }
    }
    if ((key_dtor_list_1 == 0 || ((key_dtor_list_1 != 0 && *key_dtor_list_1 != arg1) && key_dtor_list_2 == 0)))
    {
        LeaveCriticalSection(&__mingwthr_cs);
    }
    if (key_dtor_list_1 != 0)
    {
        if ((*key_dtor_list_1 != arg1 && key_dtor_list_2 != 0))
        {
            key_dtor_list_3 = key_dtor_list_2;
            *(key_dtor_list_1 + 0x10) = *(key_dtor_list_2 + 0x10);
        }
        if ((*key_dtor_list_1 == arg1 || (*key_dtor_list_1 != arg1 && key_dtor_list_2 != 0)))
        {
            free(key_dtor_list_3);
            LeaveCriticalSection(&__mingwthr_cs);
        }
    }
    return 0;
}

int64_t __mingw_TLScallback(int64_t arg1, int32_t arg2)
{
    if (arg2 == 1)
    {
        if (__mingwthr_cs_init == 0)
        {
            InitializeCriticalSection(&__mingwthr_cs);
        }
        __mingwthr_cs_init = 1;
        return 1;
    }
    if (arg2 < 1)
    {
        if (__mingwthr_cs_init != 0)
        {
            __mingwthr_run_key_dtors.part.0();
        }
        if (__mingwthr_cs_init == 1)
        {
            __mingwthr_cs_init = 0;
            DeleteCriticalSection(&__mingwthr_cs);
        }
    }
    else if ((arg2 == 3 && __mingwthr_cs_init != 0))
    {
        __mingwthr_run_key_dtors.part.0();
    }
    return 1;
}

int64_t ___chkstk_ms(int64_t arg1 @ rax)
{
    int64_t var_10 = arg1;
    void* rcx = &arg_8;
    if (arg1 >= 0x1000)
    {
        do
        {
            rcx = (rcx - 0x1000);
            *rcx = *rcx;
            arg1 = (arg1 - 0x1000);
        } while (arg1 > 0x1000);
    }
    void* rcx_1 = (rcx - arg1);
    *rcx_1 = *rcx_1;
    return var_10;
}

int64_t DllMain() __pure
{
    return 1;
}

int64_t DllEntryPoint() __pure
{
    return 1;
}

int64_t malloc(uint64_t _Size)
{
    /* tailcall */
    return malloc(_Size);
}

void _amsg_exit(int32_t rterrnum)
{
    /* tailcall */
    return _amsg_exit(rterrnum);
}

void free(void* _Block)
{
    /* tailcall */
    return free(_Block);
}

void _initterm(_PVFV* _First, _PVFV* _Last)
{
    /* tailcall */
    return _initterm(_First, _Last);
}

FILE* __iob_func()
{
    /* tailcall */
    return __iob_func();
}

int32_t fflush(FILE* _Stream)
{
    /* tailcall */
    return fflush(_Stream);
}

int32_t printf(char const* const _Format, ...)
{
    /* tailcall */
    return printf();
}

int32_t scanf(char const* const _Format, ...)
{
    /* tailcall */
    return scanf();
}

uint64_t fwrite(void const* _Buffer, uint64_t _ElementSize, uint64_t _ElementCount, FILE* _Stream)
{
    /* tailcall */
    return fwrite(_Buffer, _ElementSize, _ElementCount, _Stream);
}

int32_t vfprintf(FILE* const _Stream, char const* const _Format, va_list _ArgList)
{
    /* tailcall */
    return vfprintf(_Stream, _Format, _ArgList);
}

void abort() __noreturn
{
    /* tailcall */
    return abort();
}

int64_t memcpy(void* _Dst, void const* _Src, uint64_t _Size)
{
    /* tailcall */
    return memcpy(_Dst, _Src, _Size);
}

_crt_signal_t signal(int32_t _Signal, _crt_signal_t _Function)
{
    /* tailcall */
    return signal(_Signal, _Function);
}

void _lock(int32_t locknum)
{
    /* tailcall */
    return _lock(locknum);
}

_onexit_t __dllonexit(_onexit_t func, _PVFV** pbegin, _PVFV** pend)
{
    /* tailcall */
    return __dllonexit(func, pbegin, pend);
}

void _unlock(int32_t locknum)
{
    /* tailcall */
    return _unlock(locknum);
}

_onexit_t _onexit(_onexit_t _Func)
{
    /* tailcall */
    return _onexit(_Func);
}

uint64_t strlen(char const* _Str)
{
    /* tailcall */
    return strlen(_Str);
}

int32_t strncmp(char const* _Str1, char const* _Str2, uint64_t _MaxCount)
{
    /* tailcall */
    return strncmp(_Str1, _Str2, _MaxCount);
}

int64_t calloc(uint64_t _Count, uint64_t _Size)
{
    /* tailcall */
    return calloc(_Count, _Size);
}

void Sleep(uint32_t dwMilliseconds)
{
    /* tailcall */
    return Sleep(dwMilliseconds);
}

uint64_t* VirtualQuery(void* lpAddress, struct MEMORY_BASIC_INFORMATION* lpBuffer, uint64_t* dwLength)
{
    /* tailcall */
    return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

BOOL VirtualProtect(void* lpAddress, uint64_t* dwSize, enum PAGE_PROTECTION_FLAGS flNewProtect, enum PAGE_PROTECTION_FLAGS* lpflOldProtect)
{
    /* tailcall */
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

enum WIN32_ERROR GetLastError()
{
    /* tailcall */
    return GetLastError();
}

void GetSystemTimeAsFileTime(struct FILETIME* lpSystemTimeAsFileTime)
{
    /* tailcall */
    return GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);
}

uint32_t GetCurrentProcessId()
{
    /* tailcall */
    return GetCurrentProcessId();
}

uint32_t GetCurrentThreadId()
{
    /* tailcall */
    return GetCurrentThreadId();
}

uint32_t GetTickCount()
{
    /* tailcall */
    return GetTickCount();
}

BOOL QueryPerformanceCounter(union LARGE_INTEGER* lpPerformanceCount)
{
    /* tailcall */
    return QueryPerformanceCounter(lpPerformanceCount);
}

void RtlCaptureContext(struct CONTEXT* ContextRecord)
{
    /* tailcall */
    return RtlCaptureContext(ContextRecord);
}

struct IMAGE_RUNTIME_FUNCTION_ENTRY* RtlLookupFunctionEntry(uint64_t ControlPc, uint64_t* ImageBase, struct UNWIND_HISTORY_TABLE* HistoryTable)
{
    /* tailcall */
    return RtlLookupFunctionEntry(ControlPc, ImageBase, HistoryTable);
}

EXCEPTION_ROUTINE RtlVirtualUnwind(enum RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, uint64_t ImageBase, uint64_t ControlPc, struct IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry, struct CONTEXT* ContextRecord, void** HandlerData, uint64_t* EstablisherFrame, struct KNONVOLATILE_CONTEXT_POINTERS* ContextPointers)
{
    /* tailcall */
    return RtlVirtualUnwind(HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
}

LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
    /* tailcall */
    return SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
}

int32_t UnhandledExceptionFilter(struct EXCEPTION_POINTERS* ExceptionInfo)
{
    /* tailcall */
    return UnhandledExceptionFilter(ExceptionInfo);
}

HANDLE GetCurrentProcess()
{
    /* tailcall */
    return GetCurrentProcess();
}

BOOL TerminateProcess(HANDLE hProcess, uint32_t uExitCode)
{
    /* tailcall */
    return TerminateProcess(hProcess, uExitCode);
}

BOOLEAN RtlAddFunctionTable(struct IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionTable, uint32_t EntryCount, uint64_t BaseAddress)
{
    /* tailcall */
    return RtlAddFunctionTable(FunctionTable, EntryCount, BaseAddress);
}

void EnterCriticalSection(struct RTL_CRITICAL_SECTION* lpCriticalSection)
{
    /* tailcall */
    return EnterCriticalSection(lpCriticalSection);
}

void* TlsGetValue(uint32_t dwTlsIndex)
{
    /* tailcall */
    return TlsGetValue(dwTlsIndex);
}

void LeaveCriticalSection(struct RTL_CRITICAL_SECTION* lpCriticalSection)
{
    /* tailcall */
    return LeaveCriticalSection(lpCriticalSection);
}

void DeleteCriticalSection(struct RTL_CRITICAL_SECTION* lpCriticalSection)
{
    /* tailcall */
    return DeleteCriticalSection(lpCriticalSection);
}

void InitializeCriticalSection(struct RTL_CRITICAL_SECTION* lpCriticalSection)
{
    /* tailcall */
    return InitializeCriticalSection(lpCriticalSection);
}

